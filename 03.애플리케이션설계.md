# 스키마 설계 고려 사항
- 애플리케이션에서 원하는 방식으로 데이터를 표현하는게 가장 좋은 설계 방식이다.
- RDB와 다르게 스키마를 모델링하기 전에 쿼리 및 데이터 접근을 먼저 이해해야 한다.

## 제약사항
- 도큐먼트 최대 크기는 16MB
- 갱신은 전체 도큐먼트를 다시 쓰며, 원자성 갱신은 도큐먼트 단위로 실행된다.

## 쿼리 및 쓰기의 접근 패턴
- 애플리케이션 및 더 넓은 시스템의 워크로드(읽기,쓰기)를 식별하고 정량화해야한다.
- 쿼리가 실행되는 시기와 빈도를 알면 가장 일반적인 쿼리를 식별할 수 있다.
- 쿼리 수를 최소화하고 함께 쿼리되는 데이터가 동일한 도큐먼트에 저장되도록 설계한다.
- 이러한 쿼리에 자주 사용하지 않는 데이터는 다른 컬렉션으로 넣어준다.
- 동적(읽기/쓰기) 데이터와 정적(대부분 읽기) 데이터를 분리할 수 있는지도 생각하자.
- 스키마 설계의 우선 순위를 가장 일반적인 쿼리에 지정할 때 결과가 최상의 성능을 가진다.

## 관계 유형
- 애플리케이션 요구 사항 측면과 도큐먼트 간 관계 측에서 어떤 데이터가 관련되어 있는지 고려해야 한다.
- 쿼리하지 않고 도큐먼트를 참조하는 방법을 파악해야 한다.
- 관계가 변경될 때 갱신되는 도큐먼트 수를 알아야 한다.
- 데이터가 쿼리하기 쉬운 구조인지도 고려하자.

## 카디널리티
- SQL에서 카디널리티는 해당 테이블의 특정 컬럼의 중복되는 값의 수치를 나타내는 지표 (ex.성별 컬럼은 남성/여성으로 2의 카디널리티를 가짐)
- Data Modeling 에서의 카디널리티 한 테이블이 다른 테이블과 가질 수 있는 관계를 나타냅니다. 다대다, 다대일/일대다 또는 일대일
- 도큐먼트와 데이터가 어떻게 관련돼 있는지 확인한 후에는 카디널리티 고려
- 모델링에 최선의 형식을 사용하도록 관계의 카디널리티를 설정하는것이 매우 중요
- 데이터 필드에 대한 읽기 갱신 비율도 고려해야 함

# 스키마 설계 패턴
- 애플리케이션 성능에 직접 영향을 미치기 때문에 스키마 설계가 중요함

## 다형성 패턴
- 컬렉션 내 모든 도큐먼트가 유사하지만 동일하지 않은 구조를 가질 때 적합
- 동일하지 않은 도큐먼트로 구성된 단일 컬렉션에서 간단한 쿼리를 사용해 쿼리 성능을 향상 시킬 수 있다.

## 속성 패턴
- 정렬하거나 쿼리하려는 도큐먼트에 필드의 서브셋이 있는 경우, 정렬하려는 필드가 도큐먼트의 서브셋에만 존재하는 경우 또는 두 조건이 모두 해당하는 경우에 적합
- 도큐먼트당 많은 유사한 필드를 대상으로 지정하기에 필요한 인덱스가 적어지고 쿼리 작성이 간단해짐

## 버킷 패턴
- 데이터가 일정 기간 동안 스트림으로 유입되는 시계열 데이터에 적합
- 1시간 버킷을 사용해 해당 시간 동안의 모든 판독 값을 단일 도큐먼트 내 배열에 배치할 수 있다.

## 이상치 패턴
- 도큐먼트의 쿼리가 애플리케이션의 정삭적인 패턴을 벗어 날 때 사용
- 인기도가 중요한 상황을 위해 설계된 고급 스키마 패턴으로, 주요영향 요인, 도서 판매, 영화 리뷰 등이 있는 소셜 네트워크에서 볼 수 있다.
- 플래그를 사용해 도큐먼트가 이상점임을 나타내며 추가 오버플로를 도큐먼트에 저장한다.

## 계산된 패턴
- 데이터를 자주 계산해야 할 때나 데이터 접근 패턴이 읽기 집약적일 때 사용
- 주요 도큐먼트가 주기적으로 갱신되는 백그라운드에서 계산을 수행하도록 권장
- 읽기가 게산을 트리거하고 읽기, 쓰기 비율이 높은 경우에 특히 동일한 계산의 반복을 방지함으로써 CPU에 가해지는 부담을 크게 줄일 수 있다.

## 서브셋 패턴
- 장비의 램 용량을 초과하는 작업 셋이 있을 때 사용
- 애플리케이션에서 사용하지 않는 정보를 많이 포함하는 대용량 도큐먼트 때문에 발생할 수 있다.
- 자주 사용하는 데이터와 자주 사용하지 않는 데이터를 두 개의 개별 컬렉션으로 분할

## 확장된 참조 패턴
- 각각 고유한컬렉션이 있는 여러 논리 엔티티 또는 ‘사물’이 있고, 특정 기능을 위해 엔티티들을 모을 때 사용한다.
- 일반적인 전자상거래 스키마에서 주문, 고객, 재고에 대한 별도의 컬렉션이 있을 때 개별 컬렉션에서 단일 주문에 대한 정보를 모두 수집하면 성능에 부정적 영향이 갈 수 있다.
- 이때 자주 접근하는 필드를 식별하고 주문 도큐먼트로 복제하면 문제 해결 가능
- 데이터를 중복시키는 대신 정보를 조합하는 데 필요한 쿼리 수를 줄인다.

## 근사 패턴
- 리소스가 많이 드는 계산이 필요하지만 높은 정확도가 필요하지 않은 상황에서 좋다.
- 근사 패턴을 적용해 추천이나 조회 수가 1회가 아니라 100회가 될 때마다 카운터를 갱신하면 쓰기 횟수를 크게 줄일 수 있다.

## 트리 패턴
- 쿼리가 많고 구조적으로 주로 계층적인 데이터가 있을 때 적용한다.
- 전체 계층고조 필드는 배열에 보관돼 해당 값에 다중키 인덱스를 사용하는 기능을 제공한다.
- 즉각적인 범주 필드를 사용하면 해당 범주와 직접 관련된 모든 항목을 찾을 수 있다.

## 사전 할당 패턴
- MMAP 스토리지 엔진과 함께 사용된다.
- 빈 구조를 사전 할당한다.
- 예약정보 관리 시스템에서, 예약 가능 여부와 현재 예약 상태를 추적하는데 적용된다.
- 리소스와 날짜의 2차원 구조를 사용해 쉽게 가용성을 확인하고 계산할 수 있다.

## 도큐먼트 버전 관리 패턴
- 도큐먼트의 이전 버전을 유지하는 메커니즘을 제공
- 메인 컬렉션의 도큐먼트 버전을 추적하려면 각 도큐먼트에 부가 필드를 추가해야 함. 도큐먼트의 모든 수정 사항을 포함하는 추가 컬렉션이 필요하다.
- 패턴에는 몇가지 가정이 있다.
  - 각 도큐먼트의 버전은 개정 횟수가 제한되고, 버전 관리가 필요한 도큐먼트가 많지 않으며, 쿼리는 각 도큐먼트의 현재 버전에서 먼저 수행된다.

# 정규화 VS 비정규화
- 일반적으로 정규화는 쓰기를 빠르게 하고, 비정규화는 읽기를 빠르게 한다.

## 정규화
- 컬렉션 간의 참조를 이용해 데이터를 여러 컬렉션으로 나누는 작업
- 데이터를 변경하려면 한 도큐먼트만 갱신하면 된다.
- foreign-key로 left outer join을 수행하는 $lookup 을 제공

## 비정규화
- 모든 데이터를 하나의 도큐먼트에 내장하는 것
- 정보가 변경되면 여러 도큐먼트가 갱신돼야 하지만, 하나의 쿼리로 모든 데이터를 가져올 수 있다.

# 내장방식 vs 참조방식
- 내장방식
  - 작은 서브 도큐먼트
  - 주기적으로 변하지 않는 데이터
  - 결과적인 일관성이 허용될 때
  - 증가량이 적은 도큐먼트
  - 두 번째 쿼리를 수행하는 데 자주 필요한 데이터
  - 빠른 읽기
- 참조 방식
  - 큰 서브도큐먼트
  - 자주 변하는 데이터
  - 즉각적인 일관성이 필요할 때
  - 증가량이 많은 도큐먼트
  - 결과에서 자주 제외되는 데이터
  - 빠른 쓰기
 
## 계정 설정
- 해당 사용자 도큐먼트에만 관련 있으며, 도큐먼트 내 다른 정보와 함께 노출, 계정 설정은 일반적으로 내장되어야 함

## 최근 활동
- 최근 활동의 증가량과 변화량에 따라 다르다.
- 크기가 고정된 필드는 내장하는것이 유리

## 사용자가 생성한 모든 내용
- 내장하지 않는다.

# 데이터 조작을 위한 최적화
- 읽기 최적화는 올바른 인덱스를 사용해 하나의 도큐먼트에서 가능한 많은 정보를 반환
- 쓰기 최적화는 보통 갖고 있는 인덱스 개수를 최소화하고 갱신을 효율적으로

## 오래된 데이터 제거
- 제한컬렉션
  - 가장 쉬운방법
  - 컬렉션 크기 설정 후 오래된 데이터 밀어내게 만든다
  - 사용자 작업에 제약이 생김
  - 급격히 늘어나는 트래픽에 취약
- TTL 컬렉션
  - 도큐먼트가 제거될 때 조절가능
  - 쓰기를 많이 하는 컬렉션에서는 빠르지X
- 일정 주기로 컬렉션 삭제
  - 주기마다 컬렉션을 따로 관리한다
  - 트래픽에 버티기 좋다
  - 애플리케이션 구축이 복잡

# 데이터베이스와 컬렉션 구상
- 일반적으로 스키마가 유사한 도큐먼트는 같은 컬렉션에 보관
- 몽고db는 보통 다른 컬렉션에 있는 데이터 결합을 허용하지 않는다.
- 함께 쿼리하거나 집계해야 하는 도큐먼트는 하나의 컬렉션에 넣는게 좋다.
- 컬렉션에서 락과 저장을 고려해야 함
- 쓰기가 높다면 여러 물리적 볼륨을 통해 병목 현상을 줄일 수 있다.
- 컬렉션 내 데이터의 중요도에 따라 데이터베이스를 나눌 수 있다.
- 중요도에 따라 성능 또한 차별을 둘 수 있다.

# 일관성 관리
- 셸을 두 개 열때 데이터베이스에 대한 연결이 두개가 된다. 하나의 셸에서 insert를 하면 이후에 다른 셸에서 발생하는 쿼리는 삽입된 도큐먼트를 반환하지 못한다. 그러나 단일 셸에서 삽입하고 쿼리하면 삽입된 도큐먼트가 반환된다.
- 각 스레드에서 작동하기에 일어나는 현상, ruby, python, java에서 `connection pooling`을 사용해서 일어나는 동작
- 읽기 요청을 복제 셋의 세컨더리로 보낼 때 문제가 될 수 있다.
- 세컨더리는 초, 분, 시간 단위 전부터 데이터를 읽으므로 `primary`에 뒤처질 수 있다.
- 모든 읽기 요청을 primary에 보내면 데이터가 오래되어도 사용 가능
- `readConcern, writeConcern` 를 결합하면 애플리케이션에 대한 일관성과 가용성 보장을 제어할 수 있다.
- 읽기 부실을 방지하려면 `majority`를 사용
- 읽기 작업을 시작하기 전 완료된 쓰기를 모두 반영하는 데이터를 반환하는 `linearizable`을 사용할 수 있다.
- 결과를 반환하기 전에 동시 실행되는 쓰기가 완료될 때까지 기다리게 `linearizable readConcern`를 사용할 수 있다.

# 스키마 마이그레이션 
- 애플리케이션 규모가 커지고 요구 사항이 변할수록 스키마도 커지고 변화한다.
- 도큐먼트 버전 관리 패턴을 적용하는게 이상적이다
